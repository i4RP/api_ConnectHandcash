import { AxiosRequestConfig } from 'axios';
import { PrivateKey } from 'bsv-wasm';
import { CurrencyCode } from '../types/currencyCode';
import { PaymentParameters } from '../types/payments';
import { DataSignatureParameters } from '../types/signature';
import { HttpBody, HttpMethod, QueryParams } from '../types/http';
import { EncryptionKeypair } from '../types/account';
import { CloudEndpoint, CloudResponse } from './definitions';
import { AddMintOrderItemsParams, CreateItemsOrder, GetItemsFilter, ItemTransferResult, NewCreateItemsOrder, TransferItemParameters } from '../types/items';
type Params = {
    authToken?: string;
    appSecret: string;
    appId: string;
    baseApiEndpoint: string;
    baseTrustholderEndpoint: string;
};
export default class HandCashConnectService {
    privateKey: PrivateKey | undefined;
    appSecret: string;
    appId: string;
    baseApiEndpoint: string;
    baseTrustholderEndpoint: string;
    constructor({ authToken, appSecret, appId, baseApiEndpoint, baseTrustholderEndpoint }: Params);
    getRequest<Url extends CloudEndpoint>(method: HttpMethod, endpoint: Url, body?: HttpBody, queryParameters?: QueryParams): AxiosRequestConfig<CloudResponse[Url]>;
    getTrustholderRequest(method: HttpMethod, endpoint: string, body: HttpBody, queryParameters?: QueryParams): AxiosRequestConfig;
    static getEncodedEndpoint(endpoint: string, queryParameters: QueryParams): string;
    static getRequestSignature(method: HttpMethod, endpoint: string, serializedBody: string | undefined, timestamp: string, privateKey: PrivateKey, nonce: string): string;
    static getRequestSignaturePayload(method: HttpMethod, endpoint: string, serializedBody: string | undefined, timestamp: string, nonce: string): string;
    getCurrentProfile(): Promise<import("../types/account").UserProfile>;
    getPublicProfilesByHandle(handles: string[]): Promise<{
        items: import("../types/account").UserPublicProfile[];
    }>;
    getUserPermissions(): Promise<import("../types/account").PermissionInfo>;
    getEncryptionKeypair(encryptionPublicKey: string): Promise<EncryptionKeypair>;
    signData(dataSignatureParameters: DataSignatureParameters): Promise<import("../types/signature").DataSignature>;
    getUserFriends(): Promise<{
        items: import("../types/account").UserPublicProfile[];
    }>;
    getSpendableBalance(currencyCode?: CurrencyCode): Promise<import("../types/account").SpendableBalance>;
    getTotalBalance(): Promise<import("../types/account").UserBalance>;
    pay(paymentParameters: PaymentParameters): Promise<import("../types/payments").PaymentResult>;
    payPaymentRequest(paymentRequestId: string): Promise<import("../types/payments").PaymentResult>;
    getPayment(transactionId: string): Promise<import("../types/payments").PaymentResult>;
    getExchangeRate(currencyCode: CurrencyCode): Promise<import("../types/account").ExchangeRate>;
    pursePay(rawTransaction: string, inputParents: unknown[]): Promise<{
        partiallySignedTx: string;
    }>;
    purseBroadcast(rawTransaction: string): Promise<void>;
    ownerNextAddress(alias: string): Promise<{
        ownerAddress: string;
    }>;
    ownerSign(rawTransaction: string, inputParents: unknown[], locks: unknown[]): Promise<{
        signedTransaction: string;
    }>;
    getNftLocations(): Promise<{
        nftLocations: string[];
    }>;
    requestEmailCode(email: string, customEmailParameters?: object): Promise<string>;
    verifyEmailCode(requestId: string, verificationCode: string, publicKey: string): Promise<any>;
    createNewAccount(accessPublicKey: string, email: string, referrerAlias?: string): Promise<import("../types/account").UserPublicProfile>;
    getItemsInventory(params: GetItemsFilter): Promise<{
        items: import("../types/items").Item[];
    }>;
    getItemListings(params: GetItemsFilter): Promise<{
        items: import("../types/items").Item[];
    }>;
    createOrder(params: NewCreateItemsOrder): Promise<CreateItemsOrder>;
    getCreateItemsOrder(orderId: string): Promise<CreateItemsOrder>;
    getItemsByOrder(orderId: string): Promise<CreateItemsOrder & {
        items: import("../types/items").Item[];
    }>;
    addOrderItems({ orderId, items, itemCreationOrderType }: AddMintOrderItemsParams): Promise<CreateItemsOrder>;
    create(params: NewCreateItemsOrder): Promise<CreateItemsOrder>;
    commitOrder(orderId: string): Promise<CreateItemsOrder>;
    inscribeNextBatch(orderId: string): Promise<CreateItemsOrder>;
    transferItems(params: TransferItemParameters): Promise<ItemTransferResult>;
    static handleRequest<T>(requestParameters: AxiosRequestConfig<T>, stack: string | undefined): Promise<T>;
    static handleApiError(result: Error | {
        stack?: string;
        request: {
            path: string;
            method: string;
        };
        response: {
            status: number;
            data: {
                message: string;
                info: string;
            };
        };
    }): Error;
}
export {};
